// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tensorflow/core/framework/op_def.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tensorflow.OpDef)
pub struct OpDef {
    // message fields
    // @@protoc_insertion_point(field:tensorflow.OpDef.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:tensorflow.OpDef.input_arg)
    pub input_arg: ::std::vec::Vec<op_def::ArgDef>,
    // @@protoc_insertion_point(field:tensorflow.OpDef.output_arg)
    pub output_arg: ::std::vec::Vec<op_def::ArgDef>,
    // @@protoc_insertion_point(field:tensorflow.OpDef.control_output)
    pub control_output: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:tensorflow.OpDef.attr)
    pub attr: ::std::vec::Vec<op_def::AttrDef>,
    // @@protoc_insertion_point(field:tensorflow.OpDef.deprecation)
    pub deprecation: ::protobuf::MessageField<OpDeprecation>,
    // @@protoc_insertion_point(field:tensorflow.OpDef.summary)
    pub summary: ::std::string::String,
    // @@protoc_insertion_point(field:tensorflow.OpDef.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:tensorflow.OpDef.is_commutative)
    pub is_commutative: bool,
    // @@protoc_insertion_point(field:tensorflow.OpDef.is_aggregate)
    pub is_aggregate: bool,
    // @@protoc_insertion_point(field:tensorflow.OpDef.is_stateful)
    pub is_stateful: bool,
    // @@protoc_insertion_point(field:tensorflow.OpDef.allows_uninitialized_input)
    pub allows_uninitialized_input: bool,
    // @@protoc_insertion_point(field:tensorflow.OpDef.is_distributed_communication)
    pub is_distributed_communication: bool,
    // special fields
    // @@protoc_insertion_point(special_field:tensorflow.OpDef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpDef {
    fn default() -> &'a OpDef {
        <OpDef as ::protobuf::Message>::default_instance()
    }
}

impl OpDef {
    pub fn new() -> OpDef {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &OpDef| { &m.name },
            |m: &mut OpDef| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_arg",
            |m: &OpDef| { &m.input_arg },
            |m: &mut OpDef| { &mut m.input_arg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_arg",
            |m: &OpDef| { &m.output_arg },
            |m: &mut OpDef| { &mut m.output_arg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "control_output",
            |m: &OpDef| { &m.control_output },
            |m: &mut OpDef| { &mut m.control_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attr",
            |m: &OpDef| { &m.attr },
            |m: &mut OpDef| { &mut m.attr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OpDeprecation>(
            "deprecation",
            |m: &OpDef| { &m.deprecation },
            |m: &mut OpDef| { &mut m.deprecation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "summary",
            |m: &OpDef| { &m.summary },
            |m: &mut OpDef| { &mut m.summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &OpDef| { &m.description },
            |m: &mut OpDef| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_commutative",
            |m: &OpDef| { &m.is_commutative },
            |m: &mut OpDef| { &mut m.is_commutative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_aggregate",
            |m: &OpDef| { &m.is_aggregate },
            |m: &mut OpDef| { &mut m.is_aggregate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_stateful",
            |m: &OpDef| { &m.is_stateful },
            |m: &mut OpDef| { &mut m.is_stateful },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allows_uninitialized_input",
            |m: &OpDef| { &m.allows_uninitialized_input },
            |m: &mut OpDef| { &mut m.allows_uninitialized_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_distributed_communication",
            |m: &OpDef| { &m.is_distributed_communication },
            |m: &mut OpDef| { &mut m.is_distributed_communication },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpDef>(
            "OpDef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpDef {
    const NAME: &'static str = "OpDef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.input_arg.push(is.read_message()?);
                },
                26 => {
                    self.output_arg.push(is.read_message()?);
                },
                162 => {
                    self.control_output.push(is.read_string()?);
                },
                34 => {
                    self.attr.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deprecation)?;
                },
                42 => {
                    self.summary = is.read_string()?;
                },
                50 => {
                    self.description = is.read_string()?;
                },
                144 => {
                    self.is_commutative = is.read_bool()?;
                },
                128 => {
                    self.is_aggregate = is.read_bool()?;
                },
                136 => {
                    self.is_stateful = is.read_bool()?;
                },
                152 => {
                    self.allows_uninitialized_input = is.read_bool()?;
                },
                168 => {
                    self.is_distributed_communication = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.input_arg {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.output_arg {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.control_output {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.attr {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.deprecation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.summary.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.summary);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if self.is_commutative != false {
            my_size += 2 + 1;
        }
        if self.is_aggregate != false {
            my_size += 2 + 1;
        }
        if self.is_stateful != false {
            my_size += 2 + 1;
        }
        if self.allows_uninitialized_input != false {
            my_size += 2 + 1;
        }
        if self.is_distributed_communication != false {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.input_arg {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.output_arg {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.control_output {
            os.write_string(20, &v)?;
        };
        for v in &self.attr {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.deprecation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if !self.summary.is_empty() {
            os.write_string(5, &self.summary)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if self.is_commutative != false {
            os.write_bool(18, self.is_commutative)?;
        }
        if self.is_aggregate != false {
            os.write_bool(16, self.is_aggregate)?;
        }
        if self.is_stateful != false {
            os.write_bool(17, self.is_stateful)?;
        }
        if self.allows_uninitialized_input != false {
            os.write_bool(19, self.allows_uninitialized_input)?;
        }
        if self.is_distributed_communication != false {
            os.write_bool(21, self.is_distributed_communication)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpDef {
        OpDef::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.input_arg.clear();
        self.output_arg.clear();
        self.control_output.clear();
        self.attr.clear();
        self.deprecation.clear();
        self.summary.clear();
        self.description.clear();
        self.is_commutative = false;
        self.is_aggregate = false;
        self.is_stateful = false;
        self.allows_uninitialized_input = false;
        self.is_distributed_communication = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpDef {
        static instance: OpDef = OpDef {
            name: ::std::string::String::new(),
            input_arg: ::std::vec::Vec::new(),
            output_arg: ::std::vec::Vec::new(),
            control_output: ::std::vec::Vec::new(),
            attr: ::std::vec::Vec::new(),
            deprecation: ::protobuf::MessageField::none(),
            summary: ::std::string::String::new(),
            description: ::std::string::String::new(),
            is_commutative: false,
            is_aggregate: false,
            is_stateful: false,
            allows_uninitialized_input: false,
            is_distributed_communication: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpDef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpDef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpDef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OpDef`
pub mod op_def {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:tensorflow.OpDef.ArgDef)
    pub struct ArgDef {
        // message fields
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.description)
        pub description: ::std::string::String,
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.type)
        pub type_: ::protobuf::EnumOrUnknown<super::super::types::DataType>,
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.type_attr)
        pub type_attr: ::std::string::String,
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.number_attr)
        pub number_attr: ::std::string::String,
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.type_list_attr)
        pub type_list_attr: ::std::string::String,
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.handle_data)
        pub handle_data: ::std::vec::Vec<super::super::resource_handle::resource_handle_proto::DtypeAndShape>,
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.is_ref)
        pub is_ref: bool,
        // @@protoc_insertion_point(field:tensorflow.OpDef.ArgDef.experimental_full_type)
        pub experimental_full_type: ::protobuf::MessageField<super::super::full_type::FullTypeDef>,
        // special fields
        // @@protoc_insertion_point(special_field:tensorflow.OpDef.ArgDef.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ArgDef {
        fn default() -> &'a ArgDef {
            <ArgDef as ::protobuf::Message>::default_instance()
        }
    }

    impl ArgDef {
        pub fn new() -> ArgDef {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &ArgDef| { &m.name },
                |m: &mut ArgDef| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "description",
                |m: &ArgDef| { &m.description },
                |m: &mut ArgDef| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &ArgDef| { &m.type_ },
                |m: &mut ArgDef| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type_attr",
                |m: &ArgDef| { &m.type_attr },
                |m: &mut ArgDef| { &mut m.type_attr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "number_attr",
                |m: &ArgDef| { &m.number_attr },
                |m: &mut ArgDef| { &mut m.number_attr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type_list_attr",
                |m: &ArgDef| { &m.type_list_attr },
                |m: &mut ArgDef| { &mut m.type_list_attr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "handle_data",
                |m: &ArgDef| { &m.handle_data },
                |m: &mut ArgDef| { &mut m.handle_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "is_ref",
                |m: &ArgDef| { &m.is_ref },
                |m: &mut ArgDef| { &mut m.is_ref },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::full_type::FullTypeDef>(
                "experimental_full_type",
                |m: &ArgDef| { &m.experimental_full_type },
                |m: &mut ArgDef| { &mut m.experimental_full_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArgDef>(
                "OpDef.ArgDef",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ArgDef {
        const NAME: &'static str = "ArgDef";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.description = is.read_string()?;
                    },
                    24 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    34 => {
                        self.type_attr = is.read_string()?;
                    },
                    42 => {
                        self.number_attr = is.read_string()?;
                    },
                    50 => {
                        self.type_list_attr = is.read_string()?;
                    },
                    58 => {
                        self.handle_data.push(is.read_message()?);
                    },
                    128 => {
                        self.is_ref = is.read_bool()?;
                    },
                    138 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.experimental_full_type)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if !self.description.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.description);
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(super::super::types::DataType::DT_INVALID) {
                my_size += ::protobuf::rt::int32_size(3, self.type_.value());
            }
            if !self.type_attr.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.type_attr);
            }
            if !self.number_attr.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.number_attr);
            }
            if !self.type_list_attr.is_empty() {
                my_size += ::protobuf::rt::string_size(6, &self.type_list_attr);
            }
            for value in &self.handle_data {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if self.is_ref != false {
                my_size += 2 + 1;
            }
            if let Some(v) = self.experimental_full_type.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if !self.description.is_empty() {
                os.write_string(2, &self.description)?;
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(super::super::types::DataType::DT_INVALID) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if !self.type_attr.is_empty() {
                os.write_string(4, &self.type_attr)?;
            }
            if !self.number_attr.is_empty() {
                os.write_string(5, &self.number_attr)?;
            }
            if !self.type_list_attr.is_empty() {
                os.write_string(6, &self.type_list_attr)?;
            }
            for v in &self.handle_data {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            if self.is_ref != false {
                os.write_bool(16, self.is_ref)?;
            }
            if let Some(v) = self.experimental_full_type.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ArgDef {
            ArgDef::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.description.clear();
            self.type_ = ::protobuf::EnumOrUnknown::new(super::super::types::DataType::DT_INVALID);
            self.type_attr.clear();
            self.number_attr.clear();
            self.type_list_attr.clear();
            self.handle_data.clear();
            self.is_ref = false;
            self.experimental_full_type.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ArgDef {
            static instance: ArgDef = ArgDef {
                name: ::std::string::String::new(),
                description: ::std::string::String::new(),
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                type_attr: ::std::string::String::new(),
                number_attr: ::std::string::String::new(),
                type_list_attr: ::std::string::String::new(),
                handle_data: ::std::vec::Vec::new(),
                is_ref: false,
                experimental_full_type: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ArgDef {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("OpDef.ArgDef").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ArgDef {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ArgDef {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:tensorflow.OpDef.AttrDef)
    pub struct AttrDef {
        // message fields
        // @@protoc_insertion_point(field:tensorflow.OpDef.AttrDef.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:tensorflow.OpDef.AttrDef.type)
        pub type_: ::std::string::String,
        // @@protoc_insertion_point(field:tensorflow.OpDef.AttrDef.default_value)
        pub default_value: ::protobuf::MessageField<super::super::attr_value::AttrValue>,
        // @@protoc_insertion_point(field:tensorflow.OpDef.AttrDef.description)
        pub description: ::std::string::String,
        // @@protoc_insertion_point(field:tensorflow.OpDef.AttrDef.has_minimum)
        pub has_minimum: bool,
        // @@protoc_insertion_point(field:tensorflow.OpDef.AttrDef.minimum)
        pub minimum: i64,
        // @@protoc_insertion_point(field:tensorflow.OpDef.AttrDef.allowed_values)
        pub allowed_values: ::protobuf::MessageField<super::super::attr_value::AttrValue>,
        // special fields
        // @@protoc_insertion_point(special_field:tensorflow.OpDef.AttrDef.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AttrDef {
        fn default() -> &'a AttrDef {
            <AttrDef as ::protobuf::Message>::default_instance()
        }
    }

    impl AttrDef {
        pub fn new() -> AttrDef {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &AttrDef| { &m.name },
                |m: &mut AttrDef| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &AttrDef| { &m.type_ },
                |m: &mut AttrDef| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::attr_value::AttrValue>(
                "default_value",
                |m: &AttrDef| { &m.default_value },
                |m: &mut AttrDef| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "description",
                |m: &AttrDef| { &m.description },
                |m: &mut AttrDef| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "has_minimum",
                |m: &AttrDef| { &m.has_minimum },
                |m: &mut AttrDef| { &mut m.has_minimum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "minimum",
                |m: &AttrDef| { &m.minimum },
                |m: &mut AttrDef| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::attr_value::AttrValue>(
                "allowed_values",
                |m: &AttrDef| { &m.allowed_values },
                |m: &mut AttrDef| { &mut m.allowed_values },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AttrDef>(
                "OpDef.AttrDef",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AttrDef {
        const NAME: &'static str = "AttrDef";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.type_ = is.read_string()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_value)?;
                    },
                    34 => {
                        self.description = is.read_string()?;
                    },
                    40 => {
                        self.has_minimum = is.read_bool()?;
                    },
                    48 => {
                        self.minimum = is.read_int64()?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.allowed_values)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if !self.type_.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.type_);
            }
            if let Some(v) = self.default_value.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if !self.description.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.description);
            }
            if self.has_minimum != false {
                my_size += 1 + 1;
            }
            if self.minimum != 0 {
                my_size += ::protobuf::rt::int64_size(6, self.minimum);
            }
            if let Some(v) = self.allowed_values.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if !self.type_.is_empty() {
                os.write_string(2, &self.type_)?;
            }
            if let Some(v) = self.default_value.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if !self.description.is_empty() {
                os.write_string(4, &self.description)?;
            }
            if self.has_minimum != false {
                os.write_bool(5, self.has_minimum)?;
            }
            if self.minimum != 0 {
                os.write_int64(6, self.minimum)?;
            }
            if let Some(v) = self.allowed_values.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AttrDef {
            AttrDef::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.type_.clear();
            self.default_value.clear();
            self.description.clear();
            self.has_minimum = false;
            self.minimum = 0;
            self.allowed_values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AttrDef {
            static instance: AttrDef = AttrDef {
                name: ::std::string::String::new(),
                type_: ::std::string::String::new(),
                default_value: ::protobuf::MessageField::none(),
                description: ::std::string::String::new(),
                has_minimum: false,
                minimum: 0,
                allowed_values: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AttrDef {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("OpDef.AttrDef").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AttrDef {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AttrDef {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tensorflow.OpDeprecation)
pub struct OpDeprecation {
    // message fields
    // @@protoc_insertion_point(field:tensorflow.OpDeprecation.version)
    pub version: i32,
    // @@protoc_insertion_point(field:tensorflow.OpDeprecation.explanation)
    pub explanation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:tensorflow.OpDeprecation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpDeprecation {
    fn default() -> &'a OpDeprecation {
        <OpDeprecation as ::protobuf::Message>::default_instance()
    }
}

impl OpDeprecation {
    pub fn new() -> OpDeprecation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &OpDeprecation| { &m.version },
            |m: &mut OpDeprecation| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "explanation",
            |m: &OpDeprecation| { &m.explanation },
            |m: &mut OpDeprecation| { &mut m.explanation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpDeprecation>(
            "OpDeprecation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpDeprecation {
    const NAME: &'static str = "OpDeprecation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = is.read_int32()?;
                },
                18 => {
                    self.explanation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.version);
        }
        if !self.explanation.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.explanation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.version != 0 {
            os.write_int32(1, self.version)?;
        }
        if !self.explanation.is_empty() {
            os.write_string(2, &self.explanation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpDeprecation {
        OpDeprecation::new()
    }

    fn clear(&mut self) {
        self.version = 0;
        self.explanation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpDeprecation {
        static instance: OpDeprecation = OpDeprecation {
            version: 0,
            explanation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpDeprecation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpDeprecation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpDeprecation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpDeprecation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:tensorflow.OpList)
pub struct OpList {
    // message fields
    // @@protoc_insertion_point(field:tensorflow.OpList.op)
    pub op: ::std::vec::Vec<OpDef>,
    // special fields
    // @@protoc_insertion_point(special_field:tensorflow.OpList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpList {
    fn default() -> &'a OpList {
        <OpList as ::protobuf::Message>::default_instance()
    }
}

impl OpList {
    pub fn new() -> OpList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "op",
            |m: &OpList| { &m.op },
            |m: &mut OpList| { &mut m.op },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpList>(
            "OpList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpList {
    const NAME: &'static str = "OpList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.op.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.op {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.op {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpList {
        OpList::new()
    }

    fn clear(&mut self) {
        self.op.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpList {
        static instance: OpList = OpList {
            op: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&tensorflow/core/framework/op_def.proto\x12\ntensorflow\x1a*tensorflow\
    /core/framework/attr_value.proto\x1a)tensorflow/core/framework/full_type\
    .proto\x1a/tensorflow/core/framework/resource_handle.proto\x1a%tensorflo\
    w/core/framework/types.proto\"\xd5\t\n\x05OpDef\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x125\n\tinput_arg\x18\x02\x20\x03(\x0b2\x18.ten\
    sorflow.OpDef.ArgDefR\x08inputArg\x127\n\noutput_arg\x18\x03\x20\x03(\
    \x0b2\x18.tensorflow.OpDef.ArgDefR\toutputArg\x12%\n\x0econtrol_output\
    \x18\x14\x20\x03(\tR\rcontrolOutput\x12-\n\x04attr\x18\x04\x20\x03(\x0b2\
    \x19.tensorflow.OpDef.AttrDefR\x04attr\x12;\n\x0bdeprecation\x18\x08\x20\
    \x01(\x0b2\x19.tensorflow.OpDeprecationR\x0bdeprecation\x12\x18\n\x07sum\
    mary\x18\x05\x20\x01(\tR\x07summary\x12\x20\n\x0bdescription\x18\x06\x20\
    \x01(\tR\x0bdescription\x12%\n\x0eis_commutative\x18\x12\x20\x01(\x08R\r\
    isCommutative\x12!\n\x0cis_aggregate\x18\x10\x20\x01(\x08R\x0bisAggregat\
    e\x12\x1f\n\x0bis_stateful\x18\x11\x20\x01(\x08R\nisStateful\x12<\n\x1aa\
    llows_uninitialized_input\x18\x13\x20\x01(\x08R\x18allowsUninitializedIn\
    put\x12@\n\x1cis_distributed_communication\x18\x15\x20\x01(\x08R\x1aisDi\
    stributedCommunication\x1a\x82\x03\n\x06ArgDef\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdes\
    cription\x12(\n\x04type\x18\x03\x20\x01(\x0e2\x14.tensorflow.DataTypeR\
    \x04type\x12\x1b\n\ttype_attr\x18\x04\x20\x01(\tR\x08typeAttr\x12\x1f\n\
    \x0bnumber_attr\x18\x05\x20\x01(\tR\nnumberAttr\x12$\n\x0etype_list_attr\
    \x18\x06\x20\x01(\tR\x0ctypeListAttr\x12N\n\x0bhandle_data\x18\x07\x20\
    \x03(\x0b2-.tensorflow.ResourceHandleProto.DtypeAndShapeR\nhandleData\
    \x12\x15\n\x06is_ref\x18\x10\x20\x01(\x08R\x05isRef\x12M\n\x16experiment\
    al_full_type\x18\x11\x20\x01(\x0b2\x17.tensorflow.FullTypeDefR\x14experi\
    mentalFullType\x1a\x88\x02\n\x07AttrDef\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\x12:\n\rd\
    efault_value\x18\x03\x20\x01(\x0b2\x15.tensorflow.AttrValueR\x0cdefaultV\
    alue\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\x0bdescription\x12\x1f\
    \n\x0bhas_minimum\x18\x05\x20\x01(\x08R\nhasMinimum\x12\x18\n\x07minimum\
    \x18\x06\x20\x01(\x03R\x07minimum\x12<\n\x0eallowed_values\x18\x07\x20\
    \x01(\x0b2\x15.tensorflow.AttrValueR\rallowedValues\"K\n\rOpDeprecation\
    \x12\x18\n\x07version\x18\x01\x20\x01(\x05R\x07version\x12\x20\n\x0bexpl\
    anation\x18\x02\x20\x01(\tR\x0bexplanation\"+\n\x06OpList\x12!\n\x02op\
    \x18\x01\x20\x03(\x0b2\x11.tensorflow.OpDefR\x02opB{\n\x18org.tensorflow\
    .frameworkB\x0bOpDefProtosP\x01ZMgithub.com/tensorflow/tensorflow/tensor\
    flow/go/core/framework/op_def_go_proto\xf8\x01\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(super::attr_value::file_descriptor().clone());
            deps.push(super::full_type::file_descriptor().clone());
            deps.push(super::resource_handle::file_descriptor().clone());
            deps.push(super::types::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(OpDef::generated_message_descriptor_data());
            messages.push(OpDeprecation::generated_message_descriptor_data());
            messages.push(OpList::generated_message_descriptor_data());
            messages.push(op_def::ArgDef::generated_message_descriptor_data());
            messages.push(op_def::AttrDef::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
